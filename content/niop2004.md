---
title: 火星人手指排列问题 —— 求字典序后第 M 个排列
date: 2026-01-26
description: 介绍如何求字典序后第 M 个排列的经典解。
---
# 【算法详解】火星人手指排列问题 —— 求字典序后第 M 个排列

> **题目来源**：NOIP2004 普及组 第4题

https://www.luogu.com.cn/problem/P1088

> **核心考点**：下一个排列（Next Permutation）算法

---

## 🌍 问题简述

火星人用 $1$ 到 $N$ 的一个排列表示数字（按字典序编号，如 `123` 表示 1，`132` 表示 2……）。  
给定当前排列和一个小整数 $M$（$1 \leq M \leq 100$），要求输出**字典序后第 $M$ 个排列**。

- $1 \leq N \leq 10000$
- 结果保证在合法范围内（不会超过最大排列）

---

## 🔍 为什么不能暴力？

- 所有排列共 $N!$ 个，当 $N = 15$ 时已超 $10^{12}$，无法枚举。
- 康托展开需计算阶乘，$20!$ 已超出 64 位整数，$N=10000$ 完全不可行。

但注意：**$M \leq 100$**！  
→ 我们只需从当前排列开始，**执行 $M$ 次“下一个排列”操作**即可。

时间复杂度：$O(M \times N) \leq 100 \times 10000 = 10^6$，完全可行！

---

## ✅ 核心算法：Next Permutation（下一个排列）

目标：给定一个排列，求字典序中**紧接其后的下一个排列**。

### 🧠 算法步骤（原地修改）

1. **找最右的“可增大”位置 `i`**  
   从右往左找第一个满足 `a[i] < a[i+1]` 的下标 `i`。  
   → 此时 `a[i+1 ... end]` 是**最长非递增后缀**（已是该后缀的最大排列）。

2. **在后缀中找最小的大于 `a[i]`的元素 `a[j]`**  
   从右往左找第一个 `j > i` 使得 `a[j] > a[i]`。  
   → 因为后缀非递增，这等价于找**大于 a[i] 的最小值**。

3. **交换 `a[i]` 和 `a[j]`**  
   → 使前缀变大，且增幅最小。

4. **反转后缀 `a[i+1 ... end]`**  
   → 因为原后缀非递增，且交换后仍保持非递增（由 `j` 的选择保证），  
   → 反转后变为**升序**，即该后缀的**最小排列**。

最终结果：**刚好比原排列大的最小排列**。

---

### 📌 为什么正确？

- **找最长非递增后缀** → 确保改动位置尽可能靠右（高位不变，低位最小调整）。
- **选最右边的 `j`** → 保证：
  - 左侧元素 ≥ `a[j] > a[i]`
  - 右侧元素 ≤ `a[i]`
  - 交换后后缀**仍非递增** → 反转 = 升序 = 最小后缀。

> 💡 关键洞察：**算法通过精心选择 `j`，保证了反转操作的正确性**。

---

## 💻 实现一：不使用 STL（手写 next_permutation）

```cpp
#include <iostream>
#include <vector>
using namespace std;

bool nextPermutation(vector<int>& a) {
    int n = a.size();
    // Step 1: 找 i
    int i = n - 2;
    while (i >= 0 && a[i] >= a[i + 1]) i--;
    
    // Step 2: 找 j
    int j = n - 1;
    while (a[j] <= a[i]) j--;
    
    // Step 3: 交换
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
    
    // Step 4: 反转后缀
    int l = i + 1, r = n - 1;
    while (l < r) {
        tmp = a[l];
        a[l] = a[r];
        a[r] = tmp;
        l++;
        r--;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, M;
    cin >> N >> M;
    vector<int> a(N);
    for (int i = 0; i < N; ++i) cin >> a[i];
    
    for (int i = 0; i < M; ++i)
        nextPermutation(a);
    
    for (int i = 0; i < N; ++i) {
        if (i) cout << " ";
        cout << a[i];
    }
    cout << "\n";
    return 0;
}
```

---

## 💻 实现二：使用 STL（极简版）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, M;
    cin >> N >> M;
    vector<int> a(N);
    for (int i = 0; i < N; ++i) cin >> a[i];
    
    for (int i = 0; i < M; ++i)
        next_permutation(a.begin(), a.end());
    
    for (int i = 0; i < N; ++i) {
        if (i) cout << " ";
        cout << a[i];
    }
    cout << "\n";
    return 0;
}
```