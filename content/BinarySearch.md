---
title: 二分查找边界处理为何总是写错？——从循环不变量推导正确模版
date: 2026-02-12
description: 深入解析二分查找边界痛点，以“循环不变量”为核心概念，从错误模版倒推正确逻辑，涵盖四种主流写法的推导与修正，并给出处理“不存在结果”的通用实现。
---
# 二分查找：从错误模版到正确模版的推导之路
二分查找虽然思想简单，但边界条件（`l` 与 `r` 的处理）一直是编程中的痛点。稍有不慎，就会导致死循环、漏查或越界错误。本文将以“在数组中找最后一个小于或等于 `q` 的数的索引”为例，带你从一个个错误的模版倒推回正确的模版，深入理解其背后的逻辑。
## 核心概念：循环不变量
在开始之前，我们需要定义一个核心概念：**循环不变量**。
它是指在循环开始前、每次迭代前后、以及循环结束后都让判断语句始终为真的变量。理解了它，二分查找的边界处理便迎刃而解。
假设数组下标从 1 开始，范围为 `[1, n]`。
---
## 推导过程
### 尝试一：l 与 r 均作为循环不变量
我们很自然地想到让 `l` 和 `r` 都作为循环不变量：
- `a[l] <= q` 始终成立。
- `a[r] > q` 始终成立。
当 `l + 1 = r` 时，`l` 和 `r` 相邻，搜索空间缩小完毕，这就是循环结束的条件。
**初始模版：**
```cpp
int find(int q) {
    int l = 1, r = n;
    while (l + 1 < r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q)
            l = mid;
        else
            r = mid;
    }
    return l;
}
```
**问题分析：**
这个模版有问题吗？有。`l` 最大只能取到 `r-1`，即 `n-1`。如果答案正好是 `n`（即 `a[n] <= q`），这个模版会漏掉。
**修正尝试：**
有人可能会想，那我让 `mid` 向上取整是不是就行了？
```cpp
int mid = (l + r + 1) >> 1;
```
**问题分析：**
依然不对。循环条件 `l + 1 < r` 限制了 `l` 永远无法到达 `r`。即使向上取整，当 `l` 为 `n-1` 时，循环直接跳出了。
**正确方案：**
既然 `l` 需要能取到 `n`，而 `r` 始终代表 `> q` 的区域，那么我们应该将 `r` 的初始值设为 `n+1`，代表数组边界外的第一个“虚拟”位置。
```cpp
int find(int q) {
    int l = 1, r = n + 1; // 扩大 r 的范围
    while (l + 1 < r) {
        int mid = (l + r) >> 1; // 此时无论是否 +1 均可，因为 l+1 < r 保证了 mid 不会卡死
        if (a[mid] <= q)
            l = mid;
        else
            r = mid;
    }
    return l;
}
```
此模版中，`l + 1 < r` 保证了 `mid` 始终在 `(l, r)` 之间，不会造成死循环，且 `l` 成功覆盖到了 `n`。
---
### 尝试二：r 不再是循环不变量
这次我们试着缩小搜索空间，不让 `a[r] > q` 恒成立，而是让 `r = mid - 1` 直接排除掉大于 `q` 的部分。
此时，循环不变量变成了 `a[r+1] > q`。循环结束条件变为 `l < r`。
**初始模版：**
```cpp
int find(int q) {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q)
            l = mid;
        else
            r = mid - 1;
    }
    return l;
}
```
**问题分析：**
这会导致**死循环**。当区间长度缩小到 2 时（即 `r = l + 1`），`mid` 向下取整为 `l`。如果进入 `if (a[mid] <= q)` 分支，`l = mid = l`，区间没有缩小，程序卡死。
**正确方案：**
将 `mid` 改为向上取整。
```cpp
int find(int q) {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r + 1) >> 1; // 向上取整，解决死循环
        if (a[mid] <= q)
            l = mid;
        else
            r = mid - 1;
    }
    return l;
}
```
---
### 尝试三：l 不再是循环不变量
反过来，我们可以固定 `r` 作为循环不变量（`a[r] > q`），让 `l` 发生变化（`l = mid + 1`）。
**初始模版：**
```cpp
int find(int q) {
    int l = 1, r = n;  
    while (l < r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q)
            l = mid + 1;
        else
            r = mid; 
    }
    return l - 1;
}
```
**问题分析：**
这里有一个隐蔽的 bug。如果数组中**所有数都小于等于 `q`**，我们要找的是 `n`。
但在 `r = n` 的限制下，`l` 最终也只能到 `n`，返回 `l - 1` 即 `n - 1`。这漏掉了答案 `n`。
**正确方案：**
同样需要将 `r` 初始化为 `n + 1`。
```cpp
int find(int q) {
    int l = 1, r = n + 1;  // 扩大 r 的范围
    while (l < r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q)
            l = mid + 1;
        else
            r = mid; 
    }
    return l - 1;
}
```
---
### 尝试四：引入 ans 变量
如果我们不想纠结 `l` 和 `r` 谁是不变量，可以引入一个新的变量 `ans` 来记录答案。那出循环条件还是`l < j`吗？那肯定不是，两者此时都不是循环不变量，都没有明确的界限，所以在l==j时的情况你也要判断，才不会漏查，即 `l <= r`。
**模版：**
```cpp
int find(int q) {
    int ans = 0;
    int l = 1, r = n;  
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q) {
            ans = mid;     // 记录当前可行解
            l = mid + 1;   // 继续向右找
        } else {
            r = mid - 1; 
        }
    }
    return ans;
}
```
这个模版逻辑最清晰，不易出错。
---
## 进阶：如果找不到需要返回 0 呢？
前面的讨论基于“一定存在”的假设。如果题目要求**“找不到返回 0”**，我们需要对模版进行调整。
前两个模版（尝试一和尝试二）可以直接调整边界 `l=0` 来处理，因为它们的 `mid` 计算方式保证了不会访问 `a[0]` 导致越界。
后两个模版（尝试三和尝试四）在特定情况下可能会访问 `a[0]`（或者逻辑上不便处理 `0` 索引），因此最安全的做法是加入特判。
### 最终通用模版（支持返回 0）
**模版一(最推鉴理解记忆的一个模版)：**
```cpp
int find(int q) {
    int l = 0, r = n + 1;
    while (l + 1 < r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q)
            l = mid;
        else
            r = mid;
    }
    return l; // 找不到时 l 保持为 0
}
```
**模版二：**
```cpp
int find(int q) {
    int l = 0, r = n;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (a[mid] <= q)
            l = mid;
        else
            r = mid - 1;
    }
    return l; // 找不到时 l 保持为 0
}
```
**模版三（需特判）：**
```cpp
int find(int q) {
    int l = 1, r = n + 1;
    if (a[l] > q) return 0; // 特判第一个元素是否已超标
    while (l < r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q)
            l = mid + 1;
        else
            r = mid; 
    }
    return l - 1;
}
```
**模版四（需特判，逻辑最清晰的一个模版，也推鉴记忆）：**
```cpp
int find(int q) {
    int ans = 0;
    int l = 1, r = n;
    if (a[l] > q) return 0; // 特判
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= q) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1; 
        }
    }
    return ans;
}
```
## 总结
二分查找的边界处理看似复杂，实则遵循严格的逻辑推导。通过明确**循环不变量**，我们可以确定 `l` 和 `r` 的初始值及变化规则，从而避免死循环和漏查。在处理“找不到返回 0”的特殊情况时，务必注意数组越界访问的风险，必要时添加特判保护。