---
title: 栈的合法出栈序列数为何等于卡特兰数？——从分治结构推导
date: 2026-01-31
description: 直接从栈操作的分治结构出发，严格推导合法出栈序列数的递推公式，并证明其等价于卡特兰数，附高效 C++ 实现。
---
---

# 栈的合法出栈序列数为何等于卡特兰数？——从分治结构推导

> **题目**：给定一个入栈序列为 `1, 2, ..., n`，每次只能执行：
> - 将下一个未入栈的数压入栈（push）
> - 将栈顶元素弹出到输出序列（pop）  
> 问：有多少种不同的合法输出序列？

https://www.luogu.com.cn/problem/P1044


---

## 一、为什么不是全排列？

首先明确：**并非所有 $n!$ 种排列都能通过栈操作得到**。

例如 $n = 3$ 时，排列 `3, 1, 2` 无法实现：
- 要先输出 `3`，必须 push `1, 2, 3`；
- 此时栈为 `[1, 2, 3]`（底→顶），pop 出 `3` 后，栈顶是 `2`；
- 下一步只能 pop `2`，无法跳过它去取 `1`。

因此，合法序列数远小于 $n!$。我们需要一种能刻画栈操作约束的计数方法。

---

## 二、核心思路：按“第一个出栈的元素”分治

设 `dp[n]` 表示输入序列为 `1, 2, ..., n` 时，能生成的合法输出序列总数。

考虑这样一个关键观察：

> **在任意合法输出序列中，必然存在一个“第一个被弹出的数字”**，记为 `k`（$1 \leq k \leq n$）。

为了能让 `k` 成为第一个输出的数，操作过程必须满足：

1. 先依次 push `1, 2, ..., k`（因为输入顺序固定）；
2. 此时栈中自底向上为 `[1, 2, ..., k-1, k]`；
3. 立即 pop `k`，使其成为输出序列的第一个元素。

此时，整个问题被自然划分为两个**相互独立**的部分：

### ✅ 左侧子问题：数字 `1, 2, ..., k-1`
- 这些数**已经存在于栈中**（位于 `k` 之下）；
- 它们只能在 `k` 被弹出**之后**才可能被弹出；
- 它们的相对入栈顺序固定，且受栈规则约束；
- 因此，它们的合法出栈方式数 = `dp[k - 1]`。

### ✅ 右侧子问题：数字 `k+1, k+2, ..., n`
- 这些数**尚未入栈**；
- 它们将在 `k` 弹出后，按顺序 `k+1 → k+2 → ... → n` 被 push；
- 这一过程与左侧完全无关（栈中无交叉）；
- 因此，它们的合法出栈方式数 = `dp[n - k]`。

> 💡 关键点：左右两部分的操作虽然时间上可能交错（比如先弹一个左边的，再 push 一个右边的），但由于栈的 LIFO 特性，**左侧元素始终在右侧元素之下**，二者出栈顺序互不影响。因此，总方案数为两者的乘积。

---

## 三、推导递推公式

对每一个可能的 `k`（即第一个出栈的是 `k`），对应的方案数为：
$$
dp[k - 1] \times dp[n - k]
$$

将所有 `k` 的情况相加，得到：
$$
dp[n] = \sum_{k=1}^{n} dp[k - 1] \cdot dp[n - k]
$$

令 $i = k - 1$，则 $i$ 从 $0$ 到 $n-1$，上式等价于：
$$
\boxed{dp[n] = \sum_{i=0}^{n-1} dp[i] \cdot dp[n - 1 - i]}
$$

初始条件：`dp[0] = 1`（空序列有一种输出方式）

这正是**卡特兰数的标准递推定义**。因此：
$$
dp[n] = C_n
$$

---

## 四、C++ 实现（高效 DP）

由于 $1 \leq n \leq 18$，使用 $O(n^2)$ 的动态规划非常高效。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<long long> dp(n + 1, 0);
    dp[0] = 1; // 基础情况：空序列

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            dp[i] += dp[j] * dp[i - 1 - j];
        }
    }

    cout << dp[n] << endl;
    return 0;
}
```