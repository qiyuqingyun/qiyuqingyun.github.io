---
title: 区间调度的贪心本质：为何按结束时间排序是最优策略？
date: 2026-02-07
description: 严格证明 Interval Scheduling 问题中按结束时间贪心的最优性，剖析按开始时间或区间长度贪心的反例，揭示贪心选择性质与交换论证的数学逻辑。
---
---

# 【经典贪心】区间调度问题：最多能参加多少场比赛？

> **题目大意**：给定 $n$ 个比赛的开始和结束时间 $[a_i, b_i]$（满足 $a_i < b_i$），你不能同时参加两个比赛，且必须完整参加（不能迟到或早退）。问最多能参加多少场比赛？

这是一个经典的**区间调度（Interval Scheduling）**问题，也是贪心算法最成功的应用之一。

---

https://www.luogu.com.cn/problem/P1803

## ✅ 正确解法：按结束时间贪心

### 🧠 贪心策略
将所有比赛**按结束时间升序排序**，然后依次选择：
- 当前比赛的开始时间 $\geq$ 上一个选中比赛的结束时间；
- 则选中它，并更新“最后结束时间”。

### 📌 为什么这样是对的？——正确性证明（交换论证）

设最优解为 $OPT = \{I_1, I_2, ..., I_k\}$，其中区间按结束时间排序：$b_1 \le b_2 \le \cdots \le b_k$。  
设贪心解为 $GREEDY = \{G_1, G_2, ..., G_m\}$，同样按结束时间排序。

我们用**数学归纳 + 交换论证**说明：贪心解不会比最优解差。

1. 贪心第一步选择的是**全局最早结束的比赛** $G_1$。
   - 由于 $OPT$ 中第一个比赛 $I_1$ 的结束时间 $b_{I_1} \ge b_{G_1}$，
   - 用 $G_1$ 替换 $I_1$ 后，后续可安排的比赛**不会减少**（因为结束更早，空闲更多）。
   - 新解仍合法，且大小不变。

2. 假设前 $t-1$ 步贪心选择都不劣于最优解，考虑第 $t$ 步：
   - 贪心在剩余可选区间中选了最早结束的 $G_t$；
   - 而 $OPT$ 的第 $t$ 个区间 $I_t$ 必然也在这个候选集中（因前 $t-1$ 个已不冲突）；
   - 所以 $b_{G_t} \le b_{I_t}$，替换后仍合法。

由此可得：$m \ge k$，而 $k$ 是最大值，故 $m = k$。  
✅ **贪心解是最优解**。

---

## ❌ 为什么其他贪心策略不行？

### 1. 按**开始时间**早贪心？
**反例**：
```
3
0 100
1 2
2 3
```
- 按开始时间选 `[0,100]`，只能参加 1 场；
- 最优解是 `[1,2]` 和 `[2,3]`，共 2 场。

→ 开始早 ≠ 更优，可能“霸占”大量时间。

---

### 2. 按**区间长度短**贪心？
**反例**：
```
3
0 3
2 4
3 6
```
- 各区间长度：3, 2, 3 → 最短的是 `[2,4]`
- 若先选 `[2,4]`，则 `[0,3]`（重叠于 2 ~ 3）和 `[3,6]`（重叠于 3 ~ 4）都无法选 → 只能参加 1 场
- 但最优解是选 `[0,3]` 和 `[3,6]`（在时间点 3 衔接，允许），共 2 场
- **根本问题**：区间长度与“是否阻碍后续选择”无直接关系。

✅ 只有**结束时间**直接决定了“释放资源”的时刻，是唯一可靠的贪心依据。

---

## 💻 C++ 高效实现（O(n log n)）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<pair<int, int>> contests(n);
    for (int i = 0; i < n; ++i) {
        cin >> contests[i].first >> contests[i].second;
    }

    // 按结束时间升序排序；结束时间相同时，开始时间无所谓（可加 second 作第二关键字）
    sort(contests.begin(), contests.end(), [](const auto& x, const auto& y) {
        return x.second < y.second;
    });

    int count = 0;
    int last_end = -1; // 上一个选中比赛的结束时间

    for (int i = 0; i < n; ++i) {
        if (contests[i].first >= last_end) {
            ++count;
            last_end = contests[i].second;
        }
    }

    cout << count << '\n';
    return 0;
}
```

### 🔍 说明：
- 使用 `pair<int, int>` 存储 `(开始, 结束)`；
- `sort` 自定义比较函数，只按 `.second`（结束时间）排序；
- `last_end` 初始化为 `-1`，确保第一个比赛（即使从 0 开始）也能被选中；
- 时间复杂度：$O(n \log n)$，空间 $O(n)$，轻松通过 $n \leq 10^6$。

---

## ✅ 总结

| 策略 | 是否正确 | 原因 |
|------|--------|------|
| 按**结束时间**升序 | ✅ 正确 | 释放资源最早，留出最多空间 |
| 按**开始时间**升序 | ❌ 错误 | 可能选一个超长区间，堵死后路 |
| 按**区间长度**短 | ❌ 错误 | 长度与调度兼容性无关 |

这道题是贪心思想的典范，理解其证明过程，对掌握算法设计思想大有裨益。

--- 