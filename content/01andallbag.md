---
title: 背包计数四象限：组合与排列、01 与完全背包的四种写法全解析
date: 2026-02-03
description: 系统梳理背包计数问题的四大经典模型，通过循环顺序与状态转移逻辑，彻底厘清组合型与排列型、01 背包与完全背包的本质区别，附记忆口诀与 C++ 模板。
---
# 背包计数四象限：完全背包 vs 01背包 × 组合 vs 排列 —— 四种写法全解析

> **关键词**：动态规划、背包问题、方案数、组合、排列、循环顺序、去重

---

## 引言

在算法竞赛和面试中，背包问题的“计数变种”常常让人困惑：  
- 为什么有时候要倒序遍历容量？  
- 为什么换一下循环顺序答案就变了？  
- “选1再选2”和“选2再选1”到底算一种还是两种？

其实，所有这些差异都源于两个维度的组合：

1. **物品使用限制**：
   - **01 背包**：每种物品最多用一次
   - **完全背包**：每种物品可用无限次

2. **计数方式**：
   - **组合型（Combination）**：不考虑顺序，{A, B} = {B, A}
   - **排列型（Permutation）**：考虑顺序，[A, B] ≠ [B, A]

这两个维度交叉，正好形成 **4 种经典模型**。本文将逐一详解它们的适用场景、状态转移逻辑和代码实现，并附上记忆口诀。

---

## 一、01 背包 + 组合型（最常见）

### ✅ 问题特征
- 每种物品**只能选一次**
- 方案是**集合**，顺序无关
- **典型题目**：本题“点菜花光 M 元”、子集和问题

### 🔧 写法
```cpp
dp[0] = 1;
for (int i = 0; i < n; i++) {           // 外层：物品
    for (int j = M; j >= a[i]; j--) {   // 内层：容量倒序
        dp[j] += dp[j - a[i]];
    }
}
```

### 🧠 原理
- **倒序遍历**确保 `dp[j - a[i]]` 是**未使用当前物品**的状态
- 每个物品只被考虑一次 → 满足 01 约束
- 外层按物品推进 → 自然去重，避免顺序重复

---

## 二、01 背包 + 排列型（极少见）

### ❓ 是否存在？
严格来说，**01 背包天然不适合“排列型”计数**，因为：
- 物品不可重复
- 所有合法方案都是一个子集，其“排列”只是同一集合的不同顺序
- 若强行要求顺序不同算不同方案，则需额外记录选择路径（如 DFS），**无法用简单一维 DP 实现**

> 💡 结论：**01 背包通常只有组合型**。若题目说“顺序不同算不同”，那它很可能不是 01 背包（比如允许重复或有其他机制）。

---

## 三、完全背包 + 组合型

### ✅ 问题特征
- 物品**可无限使用**
- 方案是**多重集合**，顺序无关
- **典型题目**：硬币找零（求组合数）、凑金额（不限张数）

### 🔧 写法
```cpp
dp[0] = 1;
for (int i = 0; i < n; i++) {           // 外层：物品
    for (int j = a[i]; j <= M; j++) {   // 内层：容量正序
        dp[j] += dp[j - a[i]];
    }
}
```

### 🧠 原理
- **正序遍历**使得 `dp[j - a[i]]` 可能已包含当前物品 → 允许重复使用
- 外层按物品顺序处理 → 先固定用多少个物品0，再考虑物品1…… → **自然去重顺序**

### 📌 示例
`coins = [1, 2], M = 3`  
合法组合：{1,1,1}, {1,2} → **2 种**  
（不会把 {1,2} 和 {2,1} 分开算）

---

## 四、完全背包 + 排列型

### ✅ 问题特征
- 物品**可无限使用**
- **顺序重要**！不同选择顺序视为不同方案
- **典型题目**：爬楼梯（每次走 a[i] 步）、掷骰子得总和、字符串拼接目标值

### 🔧 写法
```cpp
dp[0] = 1;
for (int j = 1; j <= M; j++) {          // 外层：容量
    for (int i = 0; i < n; i++) {       // 内层：物品
        if (j >= a[i]) {
            dp[j] += dp[j - a[i]];
        }
    }
}
```

### 🧠 原理
- 对每个金额 `j`，尝试**最后一步**用了哪个物品
- 因为“最后一步”不同 → 路径不同 → 顺序被区分
- 允许重复使用（因 `dp[j - a[i]]` 可含任意物品）

### 📌 示例
`steps = [1, 2], M = 3`（爬3阶楼梯）  
路径：
- 1→1→1
- 1→2
- 2→1  
→ **3 种**（顺序不同即不同方案）

---

## 四种模型对比表

| 模型 | 物品限制 | 顺序是否重要 | 外层循环 | 内层循环 | 典型场景 |
|------|--------|------------|--------|--------|--------|
| **01 + 组合** | 每种 ≤1 次 | ❌ 否 | 物品 | 容量 **倒序** | 点菜、子集和 |
| **01 + 排列** | 每种 ≤1 次 | ✅ 是 | —— | —— | 极少见，通常不用 DP |
| **完全 + 组合** | 无限次 | ❌ 否 | 物品 | 容量 **正序** | 硬币找零（组合数） |
| **完全 + 排列** | 无限次 | ✅ 是 | 容量 | 物品 | 爬楼梯、掷骰子 |

---

## 🧠 核心理解：循环顺序决定“阶段”与“去重”

- **外层是“阶段”**：决定了我们按什么顺序构建方案
  - 外层是物品 → 先定“用哪些物品”，再去重顺序 → **组合**
  - 外层是容量 → 先定“达到某金额”，再看最后一步 → **排列**

- **内层方向决定“能否重复”**
  - **倒序** → 防止当前物品被多次使用 → **01 背包**
  - **正序** → 允许当前物品被重复使用 → **完全背包**

---

## ✅ 记忆口诀（必背！）

> **“组合物在外，排列容在外；  
> 01 容量倒，完全容量正。”**

> ⚠️ 注意：**01 背包没有标准的“排列型 DP 写法”**！

---

## 常见误区提醒

1. **误用完全背包写法解 01 背包**  
   → 导致物品被重复使用，答案偏大

2. **混淆“同价不同物”与“重复使用”**  
   - 两个 1 元菜是**两个不同物品**，不是“同一个物品用两次”
   - 正确 01 背包写法能区分它们（因为是两个独立物品）
   - 错误写法可能非法地用同一个 1 元菜两次

---

## 结语

掌握这四种模型，你就拥有了背包计数问题的“全景地图”。下次遇到类似题，只需问自己两个问题：

1. **物品能用几次？** → 决定 01 还是完全
2. **顺序重要吗？** → 决定组合还是排列

然后套用对应写法，轻松 AC！