---
title: 马拦过河卒的 DP 陷阱：为什么我的“事后修正”救不了边界？
date: 2025-07-27
description: 我曾以为在 DP 循环中“发现邻居非法就清零”是聪明做法。但事实证明，这种“事后修正”不仅修不全，更致命的是——它根本无法判断“连通性”。本文用我的真实错误代码为例，揭示 DP 边界处理的核心原则。
---

# 马拦过河卒的 DP 陷阱：为什么我的“事后修正”救不了边界？

> **题目简述**：卒从 `(0,0)` 走到 `(n,m)`（`1≤n,m≤20`），只能向右或向下。  
> 棋盘上有一匹马在 `(mx,my)`，其自身及 8 个“日”字控制点不可通行。  
> 求合法路径总数。

https://www.luogu.com.cn/problem/P1002

这道题我一开始信心满满地写了 DP，还加了“智能修正”逻辑：

> “如果我发现左边或上面是非法点，我就把它设为 0，这样当前点就不会加错。”

但提交后，某些测试点答案**偏大**。调试才发现：**我的“修正”根本没修到关键地方，而且逻辑上就无法处理“连通性”问题**。

今天，我就把自己的**完整错误代码**贴出来，逐行分析它为何是“无效的亡羊补牢”。

---

## ❌ 我的原始错误代码（含“事后修正”）

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int posx, posy, mx, my;
long long dp[30][30];

// 判断 (x,y) 是否可走：不是马的位置，也不在马的8个跳点上
bool iscan(int x, int y) {
    int sqr = (x - mx) * (x - mx) + (y - my) * (y - my);
    if (!(mx == x && my == y) && sqr != 5)
        return true;   // 可走
    else
        return false;  // 控制点，不可走
}

int main() {
    cin >> posx >> posy >> mx >> my;

    // ❌ 错误1：无脑初始化边界为1
    for (int i = 0; i <= posx; i++) dp[i][0] = 1;
    for (int i = 0; i <= posy; i++) dp[0][i] = 1;

    // 起点特判（此处略，非核心）
    if ((mx == 0 && my == 0) || (mx == 1 && my == 2) || (mx == 2 && my == 1)) {
        cout << 0;
        return 0;
    }

    // ❌ 错误2：试图“事后修正”邻居
    for (int i = 1; i <= posx; i++) {
        for (int j = 1; j <= posy; j++) {
            if (iscan(i, j)) {
                // 🔧 我的“修正”逻辑：
                if (!iscan(i - 1, j)) dp[i - 1][j] = 0;  // 上方非法？清零！
                if (!iscan(i, j - 1)) dp[i][j - 1] = 0;  // 左方非法？清零！
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            } else {
                dp[i][j] = 0;
            }
        }
    }

    cout << dp[posx][posy];
    return 0;
}
```

我当时觉得这个逻辑很周全：**在用邻居之前，先确保它是合法的**。

但现实狠狠打了脸。

---

## 🔥 问题一：`iscan` 只判断“是否是控制点”，不判断“是否可达”

### 🎯 反例：马在 `(3, 0)`，目标 `(5, 1)`

- `(3,0)` 是马的位置 → 控制点 → `iscan(3,0) = false`
- `(4,0)` 不是控制点 → `iscan(4,0) = true`
- 但 `(4,0)` **实际不可达**（因为 `(3,0)` 阻断了第 0 列）

在我的代码中：
- 初始化：`dp[4][0] = 1`（错误！）
- 当计算 `dp[4][1]` 时：
  ```cpp
  if (!iscan(4, 0)) dp[4][0] = 0;  // ← 不会执行！因为 iscan(4,0)=true
  ```
- 所以 `dp[4][1] += dp[4][0] = 1` → **计入一条不存在的路径！**

> 💡 **关键洞察**：  
> `iscan(x,y)` 只回答：“`(x,y)` 是马踩过的地方吗？”  
> 它**完全不关心**：“卒能不能走到 `(x,y)`？”  
>   
> 而 DP 需要的是后者——**可达性（connectivity）**，不是静态合法性。

---

## 🔥 问题二：修正机制天然无法覆盖边界 —— 不是“忘了”，而是“设计上就做不到”

我的修正逻辑确实会检查邻居：

```cpp
if (!iscan(i - 1, j)) dp[i - 1][j] = 0;   // 检查上方
if (!iscan(i, j - 1)) dp[i][j - 1] = 0;   // 检查左方
```

但主循环是：
```cpp
for (int i = 1; i <= posx; i++)
    for (int j = 1; j <= posy; j++)
```

这意味着：
- 所有被检查的 `(i-1, j)` 满足 `j ≥ 1` → **永远不会检查第 0 列**
- 所有被检查的 `(i, j-1)` 满足 `i ≥ 1` → **永远不会检查第 0 行**

🔍 于是：
- `dp[4][0]`、`dp[5][0]` 等第 0 列点 **永远不会作为 `(i, j-1)` 被访问**
- `dp[0][3]`、`dp[0][5]` 等第 0 行点 **永远不会作为 `(i-1, j)` 被访问**

→ 即使它们因前方被堵而不可达，**也永远不会被修正**，永远保持初始化的 `1`。

> 📌 这就是“**修了，但没全部都修**”——  
> 我的修正机制在**结构上就排除了整条边界**。

---

## ✅ 正确写法：用递推传递可达性，而非依赖修正

真正的解决方案，是**放弃“修正”思维**，让每个状态在诞生时就正确：

```cpp
// 预处理 blocked 数组（略）

// ✅ 正确初始化：边界也要递推！
dp[0][0] = blocked[0][0] ? 0 : 1;
for (int i = 1; i <= n; i++)
    dp[i][0] = blocked[i][0] ? 0 : dp[i-1][0];  // ← 关键：传递可达性
for (int j = 1; j <= m; j++)
    dp[0][j] = blocked[0][j] ? 0 : dp[0][j-1];

// 内部递推
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        dp[i][j] = blocked[i][j] ? 0 : dp[i-1][j] + dp[i][j-1];
```

这句话 `dp[i][0] = blocked[i][0] ? 0 : dp[i-1][0]` 的含义是：
> “我能到 `(i,0)`，当且仅当：  
> （1）我不是控制点，且  
> （2）我能到 `(i-1,0)`。”

这**自动处理了连通性**：只要前面断了，后面全是 0。

---

## 📜 自我告诫：三条 DP 铁律

1. **不要混淆“非控制点”和“可达点”**  
   ——一个点没被马控制，不代表卒能走到那里。

2. **边界不是特例，而是递推链的起点**  
   ——必须通过 `dp[i][0] = f(dp[i-1][0])` 传递可达性。

3. **永远不要“事后修正”历史状态**  
   ——如果你需要修改已计算的 `dp[a][b]`，说明你的初始化或转移逻辑有缺陷。

---

## ✅ 结语

我的“事后修正”代码，代表了一种常见误区：  
**试图用局部、静态的合法性判断，去修补全局、动态的可达性缺失。**

但 DP 不是打补丁的游戏。  
它的力量来自于**状态转移的确定性和无后效性**——每个状态在写入时就必须是最终答案。

> **真正的鲁棒性，来自于对边界的敬畏，而非对错误的修补。**

下次写 DP，请默念：

> **“我的边界，是否经得起连通性的考验？”**

只有这样，才能写出既正确又健壮的代码。

---