---
title: 铺砖问题的动态规划解法：从缺角状态到线性递推的完整推导
date: 2026-02-05
description: 深入剖析 2×N 墙铺砖问题中 L 型砖带来的状态复杂性，揭示为何必须引入辅助状态 g[n]，并通过代数消元推导出简洁递推式 f[n] = 2f[n−1] + f[n−3]，提炼组合计数类 DP 的建模原则。
---
# 用 Domino 和 Tromino 铺满 2×N 墙：动态规划解法详解

在算法竞赛中，铺砖问题是一类经典组合计数问题。本文将深入剖析一个变种：**用 1×2 的矩形砖（Domino）和 L 型三格砖（Tromino）铺满 2×N 的墙壁，求方案总数**。我们将从建模、状态定义、转移方程推导，一直到代码实现，完整呈现解决过程。

---

## 🧱 问题描述

- 墙壁尺寸：2 行 N 列（共 2N 个格子）
- 砖块类型：
  - **Domino**：1×2 矩形砖，可旋转 → 占 2 格
    - 竖放：覆盖一列的两个格子
    - 横放：需上下各一块，覆盖两列的同一行
  - **Tromino**：L 型三格砖，有 4 种旋转

https://www.luogu.com.cn/problem/P1990

> **示例**：2×3 墙有 5 种铺法（题目给出），2×13 的答案是 13465 → 输出 `3465`（最后 4 位）。

---

## ❓ 为什么不能直接用 `f[n]`？

初看之下，我们可能想定义 `f[n]` 为铺满 2×n 的方案数，并尝试分类讨论最后几列怎么铺。

但 **L 型砖会制造“缺角”状态** —— 比如某一列只铺了上半部分，下半部分空着。这种“不平整”的中间状态无法用 `f[k]` 描述，却又是合法的铺砖过程。

因此，**必须引入辅助状态**来捕捉这些“未完成但可继续铺”的轮廓。

---

## 📌 状态定义

我们定义两个状态：

### ✅ `f[n]`
> 铺满 **完整的 2×n 矩形** 的方案数。

### ✅ `g[n]`
> 铺成 **“单侧突出”形状** 的方案数（称为“缺角状态”）：
> ```
> □□□□    ← 第 n 列已铺，第 (n+1) 列顶部多一格
> □□□     ← 第 (n+1) 列底部为空
> ```
> 共覆盖 `2n + 1` 个格子。  
> 由于上下对称，底部突出的情况数量相同，故 `g[n]` 代表其中一种的数量。

> 💡 直观理解：`g[n]` 是“差一块 L 型砖就能变成完整 2×(n+1)”的中间状态。

---

## 🔁 状态转移方程

### 1. 如何得到 `f[n]`？（完整 2×n）

考虑最后一步操作：

- **竖 Domino**：在 `f[n−1]` 右侧加一个竖砖 → 贡献 `f[n−1]`
- **横 Domino**：在 `f[n−2]` 右侧加两个横砖（上下叠） → 贡献 `f[n−2]`
- **L 型补缺**：在 `g[n−2]` 状态下，加一个 L 型砖补平缺口  
  - `g[n−2]` 表示突出在第 (n−1) 列
  - 加 L 型后覆盖第 (n−1) 和 n 列，形成完整 2×n
  - 有“上突”和“下突”两种 `g[n−2]`，每种对应一种 L 型 → 共 `2·g[n−2]`

✅ 得到：
$$
\boxed{f[n] = f[n-1] + f[n-2] + 2 \cdot g[n-2]} \tag{1}
$$

> 🔍 为什么是 `g[n−2]`？  
> 因为 `g[k]` 的突出在第 (k+1) 列，要补平到第 n 列，需 `k+1 = n−1 ⇒ k = n−2`。

---

### 2. 如何得到 `g[n]`？（单侧突出）

- **制造突出**：从 `f[n−1]` 放一个 L 型砖，覆盖第 n 列两格 + 第 (n+1) 列一格 → 贡献 `f[n−1]`
- **推进突出**：从 `g[n−1]` 在“长行”横放 Domino，把突出向右推一列 → 贡献 `g[n−1]`

✅ 得到：
$$
\boxed{g[n] = f[n-1] + g[n-1]} \tag{2}
$$

---

## 🧮 初始条件与验证

手动计算小值：

| n | f[n] | g[n] | 说明 |
|---|------|------|------|
| 0 | 1    | 0    | 空墙 |
| 1 | 1    | 1    | f[1]=竖砖；g[1]=L型制造突出 |
| 2 | 2    | 2    | f[2]=①两竖 ②两横 |

验证：
- `f[2] = f[1] + f[0] + 2·g[0] = 1 + 1 + 0 = 2` ✅
- `f[3] = f[2] + f[1] + 2·g[1] = 2 + 1 + 2 = 5` ✅（题目给出）
- `f[4] = 5 + 2 + 2·2 = 11` ✅

---

## 🧠 消去辅助状态：推导纯 `f` 递推式

目标：从 (1)(2) 消去 `g`，得到只含 `f` 的公式。

### 步骤 1：代入 `g[n−2]`
由 (2)：`g[n−2] = f[n−3] + g[n−3]`  
代入 (1)：
$$
f[n] = f[n-1] + f[n-2] + 2f[n-3] + 2g[n-3] \tag{3}
$$

### 步骤 2：表达 `2g[n−3]`
对 (1) 令 `n → n−1`：
$$
f[n-1] = f[n-2] + f[n-3] + 2g[n-3] \\
\Rightarrow 2g[n-3] = f[n-1] - f[n-2] - f[n-3] \tag{4}
$$

### 步骤 3：代入消元
将 (4) 代入 (3)：
$$
\begin{aligned}
f[n] &= f[n-1] + f[n-2] + 2f[n-3] + (f[n-1] - f[n-2] - f[n-3]) \\
&= 2f[n-1] + f[n-3]
\end{aligned}
$$

✅ 最终递推式：
$$
\boxed{f[n] = 2f[n-1] + f[n-3] \quad (n \geq 3)}
$$

### 初始值：
- `f[0] = 1`
- `f[1] = 1`
- `f[2] = 2`

验证：
- `f[3] = 2×2 + 1 = 5`
- `f[4] = 2×5 + 1 = 11`
- `f[5] = 2×11 + 2 = 24`
- `f[6] = 2×24 + 5 = 53` ✅

---

## 💻 C++ 代码实现

由于 N 最大为 1,000,000，且只需输出最后 4 位，我们使用滚动数组优化空间，并每一步取模。

```cpp
#include <iostream>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    if (N == 0) {
        cout << 1 << '\n';
        return 0;
    }
    if (N == 1) {
        cout << 1 << '\n';
        return 0;
    }
    if (N == 2) {
        cout << 2 << '\n';
        return 0;
    }

    // f0 = f[n-3], f1 = f[n-2], f2 = f[n-1]
    int f0 = 1; // f[0]
    int f1 = 1; // f[1]
    int f2 = 2; // f[2]
    int fn;

    for (int i = 3; i <= N; ++i) {
        fn = (2 * f2 + f0) % 10000;
        // 滚动更新
        f0 = f1;
        f1 = f2;
        f2 = fn;
    }

    cout << fn << '\n';
    return 0;
}
```

### 代码说明：
- **时间复杂度**：O(N)
- **空间复杂度**：O(1)
- 每一步 `% 10000` 防止溢出并保留最后 4 位
- 使用滚动变量 `f0, f1, f2` 避免开大数组

---

## ✅ 总结

- **核心难点**：L 型砖导致中间状态“不平整”，需引入辅助状态 `g[n]`
- **关键技巧**：通过状态转移 + 代数消元，得到简洁递推式 `f[n] = 2f[n−1] + f[n−3]`
- **工程优化**：滚动数组 + 模运算，高效处理大 N

该问题完美展示了动态规划在组合计数中的威力：**将复杂的铺砖过程，转化为简单的线性递推**。