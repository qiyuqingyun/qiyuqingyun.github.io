---
title: 分治构造还是暴力回溯？缺角棋盘覆盖问题的优雅解法
date: 2026-02-06
description: 深入解析 NOI 经典“L形地毯覆盖”问题：为何无需状态数组、不用回溯，仅靠分治递归即可构造唯一解？递归深度仅为 k ≤ 10，却能输出 35 万块地毯。附完整 C++ 实现、类型编号对照与常见误区剖析。
---
---

# 🧩 分治经典：用 L 形地毯铺满缺角棋盘

> **关键词**：分治算法、递归、L形骨牌覆盖、缺角棋盘

---

## 一、问题描述

给定一个 $2^k \times 2^k$ 的棋盘（$1 \leq k \leq 10$），其中恰好有一个格子被“挖掉”（即公主所在位置）。  
现在要用 **L 形地毯**（由 3 个格子组成，如下图）将剩余所有格子恰好覆盖，且不能重叠。

L 形地毯有 4 种类型（以拐角位置定义）：

```
类型1:   类型2:   类型3:   类型4:
█ █        █        █ █      █
█          █ █      █        █ █
```

**输入**：`k` 和公主位置 `(x, y)`（1-indexed）  
**输出**：每行输出一块地毯的 **拐角坐标 (r, c)** 和 **类型 t**

> 示例输入：
> ```
> 3
> 3 3
> ```
> 示例输出（第一行）：
> ```
> 5 5 1
> ```

---

https://www.luogu.com.cn/problem/P1228

## 二、核心思想：分治 + 构造性递归

这道题是**分治算法的经典范例**。关键在于：

> **不需要尝试、回溯或记录状态，而是通过递归结构直接构造出唯一合法解。**

### ✅ 为什么能分治？

- 初始棋盘大小为 $2^k \times 2^k$，可划分为 4 个 $2^{k-1} \times 2^{k-1}$ 的子棋盘。
- 公主只在一个子棋盘中 → 其他三个子棋盘是“完整”的。
- 我们在**中心区域放一块 L 形地毯**，覆盖其他三个子棋盘各一个格子 → 使每个子棋盘都变成“缺一角”的合法子问题！

如此递归下去，直到 $k=0$（1×1 棋盘）。

---

## 三、坐标系统与实现细节

### 📌 坐标选择：全 1-based（推荐）

- 输入输出均为 1-based，避免混淆。
- 初始调用：`solve(1, 1, k, px, py)`
- 当前棋盘范围：`[x, x + 2^k - 1] × [y, y + 2^k - 1]`

### 🔑 中心四个关键点（1-based）

设 `mid = 2^(k-1)`，则：

| 象限 | 关键点（靠近中心的角） |
|------|------------------|
| 左上 | `(x + mid - 1, y + mid - 1)` → A |
| 右上 | `(x + mid - 1, y + mid)`     → B |
| 左下 | `(x + mid, y + mid - 1)`     → C |
| 右下 | `(x + mid, y + mid)`         → D |

### 🧭 根据公主位置决定地毯类型

| 公主位置 | 放置的 L 形覆盖 | 拐角位置 | 输出类型 |
|--------|--------------|--------|--------|
| 左上   | B, C, D      | D      | 1      |
| 右上   | A, C, D      | C      | 2      |
| 左下   | A, B, D      | B      | 3      |
| 右下   | A, B, C      | A      | 4      |

> 💡 **记忆技巧**：输出的是“**不含公主的那个对角点**”，类型编号按顺时针 1→2→3→4。

---

## 四、完整 C++ 代码（1-based，清晰高效）

```cpp
#include <iostream>
using namespace std;

void solve(int x, int y, int k, int px, int py) {
    if (k == 0) return;
    
    int mid = 1 << (k - 1);  // 2^(k-1)

    // 四个中心点（1-based）
    int Ax = x + mid - 1, Ay = y + mid - 1;  // 左上
    int Bx = x + mid - 1, By = y + mid;      // 右上
    int Cx = x + mid,     Cy = y + mid - 1;  // 左下
    int Dx = x + mid,     Dy = y + mid;      // 右下

    if (px <= Ax && py <= Ay) {
        cout << Dx << " " << Dy << " " << 1 << '\n';
        solve(x, y, k - 1, px, py);
        solve(x, y + mid, k - 1, Bx, By);
        solve(x + mid, y, k - 1, Cx, Cy);
        solve(x + mid, y + mid, k - 1, Dx, Dy);
    }
    else if (px <= Ax && py >= By) {
        cout << Cx << " " << Cy << " " << 2 << '\n';
        solve(x, y, k - 1, Ax, Ay);
        solve(x, y + mid, k - 1, px, py);
        solve(x + mid, y, k - 1, Cx, Cy);
        solve(x + mid, y + mid, k - 1, Dx, Dy);
    }
    else if (px >= Cx && py <= Ay) {
        cout << Bx << " " << By << " " << 3 << '\n';
        solve(x, y, k - 1, Ax, Ay);
        solve(x, y + mid, k - 1, Bx, By);
        solve(x + mid, y, k - 1, px, py);
        solve(x + mid, y + mid, k - 1, Dx, Dy);
    }
    else {
        cout << Ax << " " << Ay << " " << 4 << '\n';
        solve(x, y, k - 1, Ax, Ay);
        solve(x, y + mid, k - 1, Bx, By);
        solve(x + mid, y, k - 1, Cx, Cy);
        solve(x + mid, y + mid, k - 1, px, py);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int k, x, y;
    cin >> k >> x >> y;
    solve(1, 1, k, x, y);  // 全 1-based
    return 0;
}
```

---

## 五、复杂度分析

| 项目 | 复杂度 |
|------|--------|
| 时间 | $O(4^k)$ —— 总共输出 $\frac{4^k - 1}{3}$ 行 |
| 空间 | $O(k)$ —— 递归深度仅为 $k \leq 10$ |
| 内存 | **无需二维数组**！纯构造，空间效率极高 |

> ✅ 即使 $k=10$（棋盘 1024×1024），也只需 10 层递归，安全无栈溢出。

---

## 六、常见误区

1. **试图用 DFS/回溯**→ 指数爆炸，不可行。
2. **开大数组记录状态** → 不必要，且可能 MLE。
3. **混合 0-based 和 1-based 坐标** → 导致递归参数错乱。
4. **中心点计算错误（忘记 `-1`）** → 象限判断失效。

---

## 七、总结

这道题完美展示了**分治算法的威力**：

> **通过结构化分解，将复杂问题转化为相同形式的子问题，并在每层“主动制造条件”使子问题合法。**

它不需要暴力搜索，也不需要状态记录，仅靠递归逻辑就能**直接构造出唯一解**。这也是算法竞赛中“思维题”的典型代表。

---