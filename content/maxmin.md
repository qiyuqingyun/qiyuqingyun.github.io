---
title: 为什么“最大化最小值”问题要用二分答案？
date: 2026-02-10
description: 深入解析“最大化最小值”类问题的通用解法——二分答案 + 贪心验证，并以分组合法小组为例，详解其正确性与实现细节。
---
# 为什么“最大化最小值”问题要用二分答案？——以分组合法小组为例

在算法竞赛中，我们经常遇到一类经典问题：**最大化最小值**（或其对偶问题：最小化最大值）。这类问题看似简单，却往往无法通过直接贪心求解。本文将以一道典型题目为例，深入剖析为何要采用「二分答案 + 贪心验证」的策略，并详解其正确性。

---

## 🎯 题目简述

给定 $n$ 个队员的实力值（可重复、可为负数），要求将他们分成若干**合法小组**：
- 每组内的实力值构成**连续整数**（如 `[2,3,4]`）
- 同一组内**不能有重复值**
- 每个队员必须恰好属于一个小组

目标是：**使得人数最少的小组的人数尽可能大**。

输出这个最大可能的最小人数。

---

https://www.luogu.com.cn/problem/P4447

## ❌ 为什么不能直接贪心？

直觉上，我们可能会尝试：
- 排序后从左到右，把最长的连续段作为一组
- 或者尽量让每组长度相等

但这些策略都会失败。考虑以下反例：

```text
输入：[1, 2, 3, 4, 4, 5, 6]，期望 k=3
```

- 若先取 `[1,2,3]`，再取 `[4,5,6]`，会剩下一个 `4` 无法成组 → 错误认为 k=3 不可行
- 但正确分法是：`[1,2,3,4]` 和 `[4,5,6]` —— **第一个 `4` 应该延长旧组，而不是开新组！**

问题在于：**局部最优 ≠ 全局最优**。我们不知道当前数字该用于“延长旧组”还是“开新组”，才能保证最终所有组 ≥ k。

> **直接构造最优解需要全局信息，而贪心缺乏回溯能力。**

---

## ✅ 转换思路：二分答案 + 可行性验证

既然直接求最优解困难，我们换个角度：

> **猜一个答案 `k`，问：“能否让所有小组人数 ≥ k？”**

这就是一个**判定性问题（Yes/No）**，通常更容易解决。

更重要的是，这个问题具有**单调性**：

- 如果 `k` 可行（所有组 ≥ k），那么任意 `k' < k` 也一定可行
- 如果 `k` 不可行，那么任意 `k' > k` 也不可行

因此，可行的 `k` 呈现“前缀可行、后缀不可行”的结构：

```
k:      1    2   3    4   5
可行?   ✅  ✅  ✅  ❌  ❌
                 ↑
           最大可行值
```

这正是**二分查找**的经典应用场景！

---

## 🔍 如何验证 `check(k)`？

给定 `k`，我们需要判断是否存在一种分组方式，使得每组人数 ≥ k。

### 核心贪心策略（来自 LeetCode 1296）

> **优先将当前数字接到已有小组末尾；只有无法接时，才新开小组。**

为什么这个贪心是正确的？

1. **所有新开小组在创建时就保证长度 = k**
2. **延长操作只会让小组变长（≥ k+1），不会变短**
3. **延长节省了后续资源（如 `x+1, x+2`），避免浪费**

### 数据结构设计

- `freq[x]`：实力值 `x` 的剩余人数（用 `map` 自动排序）
- `tail[x]`：有多少个小组以 `x-1` 结尾，正等待 `x` 来延长

### 算法流程

对每个实力值 `x`（从小到大）：
1. **先延长旧组**：用 `x` 满足 `tail[x]` 的需求
2. **再开新组**：若还有剩余 `x`，则以 `x` 为起点开 `cnt` 个新组，每个需连续 `k` 个数
   - 若任一 `x+i` 数量不足 → `k` 不可行

> ✅ 关键：**第一个组必然通过“开新组”创建（因 `tail[x]=0`），保证初始合法性**

---

## 💻 完整代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <map>
using namespace std;

// 验证：是否能让所有小组人数 >= k
bool check(int k, map<long long, int> freq) {
    unordered_map<long long, int> tail; // tail[x]: 等待 x 的小组数

    for (auto& p : freq) {
        long long x = p.first;
        int cnt = p.second;
        if (cnt <= 0) continue;

        // 1. 优先延长已有小组
        if (tail[x] > 0) {
            int take = min(tail[x], cnt);
            tail[x] -= take;
            tail[x + 1] += take;
            cnt -= take;
        }

        // 2. 剩余的 x 用于开新组
        if (cnt > 0) {
            // 新开 cnt 个以 x 开头的组，每组至少 k 人
            for (int i = 0; i < k; ++i) {
                long long y = x + i;
                if (freq[y] < cnt) {
                    return false; // 无法组成完整小组
                }
                freq[y] -= cnt;
            }
            tail[x + k] += cnt; // 这些新组现在等待 x+k
        }
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<long long> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    // 统计频次（map 自动排序）
    map<long long, int> freq;
    for (long long x : a) {
        freq[x]++;
    }

    // 二分答案：最小小组人数的最大可能值
    int low = 1, high = n, ans = 1;
    while (low <= high) {
        int mid = low + (high - low) / 2; // 防溢出
        if (check(mid, freq)) {
            ans = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    cout << ans << '\n';
    return 0;
}
```

---

## 📌 总结与启示

1. **“最大化最小值”或“最小化最大值”问题，优先考虑二分答案，但是不是都适用，要具备“单调性”**
   - 具备单调性
   - 验证比构造更容易

2. **验证函数的设计是关键**
   - 本题使用 `tail` 机制实现最优贪心
   - 核心思想：**能延长旧组，就不开新组**

3. **初始化逻辑自洽**
   - 第一个组必由“开新组”创建（`tail[x]=0`）
   - 后续 `tail` 由分组行为自然产生

> 💡 **记住这个模板：最大最小 → 二分答案；验证用贪心模拟。**  
> 这是解决此类问题的黄金法则。

通过本题，我们不仅学会了一种解法，更掌握了一种**将优化问题转化为判定问题**的思维方式——这正是算法设计的精髓所在。