---
title: 差分思想的优雅应用：从填平道路看贪心与序列变化的本质
date: 2026-02-09
description: 深入解析“填平下陷道路”这一经典问题，揭示其背后隐藏的差分结构与贪心逻辑。通过对比暴力模拟与线性扫描解法，阐明如何利用相邻高度差避免冗余操作，并提炼出“无显式差分数组却用差分思想”的算法设计范式，展现 O(n) 解法的简洁与力量。
---
---

# 用差分思想解决经典贪心问题：最少天数填平道路

> **题目来源**：洛谷 P1031 / NOIP 类经典题  
> **关键词**：贪心、差分、前缀和、区间操作、线性扫描

---

## 🧩 问题描述

春春要铺设一条长度为 $ n $ 的道路。初始时，第 $ i $ 块区域下陷深度为 $ d_i $。

每天，他可以选择一个**连续区间** $[L, R]$，对其中每一块区域填充一次（深度减 1），但要求该区间内所有区域当前深度 **不为 0**。

问：**最少需要多少天**，才能让所有区域的下陷深度变为 0？

https://www.luogu.com.cn/problem/P5019

---

## 🚩 输入输出示例

**输入**：
```
6
4 3 2 5 3 5
```

**输出**：
```
9
```

**解释**：一种最优方案使用 9 次操作，例如多次选择不同区间逐步填平。

---

## ❌ 直觉误区：模拟每一天？

乍一看，可能会想：  
- 每次找一个最长的非零连续段，填一次；
- 重复直到全为 0。

但这样模拟的时间复杂度高达 $ O(n \cdot \max(d_i)) $，在 $ n = 10^5, d_i = 10^4 $ 时完全不可行。

我们需要一个**更聪明的观察**。

---

## 🔍 核心洞察：从“高度差”看问题

把数组 $ d = [d_1, d_2, ..., d_n] $ 看作一个**柱状图**，每个位置的高度就是下陷深度。

每天的操作相当于**在任意连续非零区间上“削掉一层”**。

那么，**总共需要多少层？**

关键发现：

> **每当当前高度比左边高，多出来的部分必须由新的“操作层”来覆盖。**

换句话说，如果 $ d[i] > d[i-1] $，那么多出的 $ d[i] - d[i-1] $ 层**无法被前面的操作覆盖**，必须新开这么多天。

而如果 $ d[i] \leq d[i-1] $，则前面的操作可以自然延伸过来，无需新增天数。

我们还可以认为在最左边有一个虚拟的 $ d_0 = 0 $。

---

## ✅ 数学表达

答案即为：

$$
\text{ans} = \sum_{i=1}^{n} \max(0, d_i - d_{i-1})
$$

其中 $ d_0 = 0 $。

这本质上是在计算所有“上升沿”的高度增量之和。

---

## 🧪 验证样例

输入：`[4, 3, 2, 5, 3, 5]`

| i | d[i] | d[i-1] | max(0, d[i]-d[i-1]) |
|---|------|--------|---------------------|
| 1 | 4    | 0      | 4                   |
| 2 | 3    | 4      | 0                   |
| 3 | 2    | 3      | 0                   |
| 4 | 5    | 2      | 3                   |
| 5 | 3    | 5      | 0                   |
| 6 | 5    | 3      | 2                   |

总和：$ 4 + 0 + 0 + 3 + 0 + 2 = 9 $ ✅

---

## 🔄 与“差分”的关系

虽然我们没有显式构建差分数组，但这个解法**本质是差分思想的应用**：

- 定义差分：$ \Delta_i = d_i - d_{i-1} $
- 只有当 $ \Delta_i > 0 $ 时，才对答案有贡献
- 总操作次数 = 所有正差分值之和

这正是**利用差分分析变化量**的典型场景——不是用于区间加法，而是用于**统计必要操作次数**。

> 💡 差分不仅是“区间更新”的工具，更是“分析序列变化”的利器。

---

## 💻 代码实现（O(n) 时间，O(1) 空间）

### C++
```cpp
#include <iostream>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    long long ans = 0;
    int prev = 0, x;
    for (int i = 0; i < n; ++i) {
        cin >> x;
        if (x > prev) ans += (x - prev);
        prev = x;
    }
    cout << ans << '\n';
    return 0;
}
```

> 注意：使用 `long long` 防止整数溢出（最大可能接近 $ 10^9 $）。

---

## 📌 总结

| 方法 | 时间复杂度 | 是否可行 |
|------|------------|--------|
| 模拟每天操作 | $ O(n \cdot \max d_i) $ | ❌ 超时 |
| 贪心 + 差分思想 | $ O(n) $ | ✅ 最优 |

这道题完美展示了：

- **贪心策略**如何通过局部最优（只关注上升沿）得到全局最优；
- **差分思想**如何跳出“区间更新”的框架，用于**高效分析序列变化**；
- **避免模拟**，用数学洞察降低复杂度。

---

## 📘 延伸思考

- 如果允许填充时跳过某些区域（非连续）？ → 问题退化为 `sum(d)`
- 如果每次只能填长度为 k 的区间？ → 需要滑动窗口或 DP
- 二维版本（填平一个矩阵）？ → 可用**二维差分**处理

---